#!/usr/bin/env node


/* @flow */

'use strict';

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x3, _x4, _x5) { var _again = true; _function: while (_again) { var object = _x3, property = _x4, receiver = _x5; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x3 = parent; _x4 = property; _x5 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

exports.evaluate = evaluate;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

var _lodashCollectionAll = require('lodash/collection/all');

var _lodashCollectionAll2 = _interopRequireDefault(_lodashCollectionAll);

var _lodashCollectionAny = require('lodash/collection/any');

var _lodashCollectionAny2 = _interopRequireDefault(_lodashCollectionAny);

var _lodashCollectionFilter = require('lodash/collection/filter');

var _lodashCollectionFilter2 = _interopRequireDefault(_lodashCollectionFilter);

var _lodashUtilityIdentity = require('lodash/utility/identity');

var _lodashUtilityIdentity2 = _interopRequireDefault(_lodashUtilityIdentity);

var _lodashCollectionIncludes = require('lodash/collection/includes');

var _lodashCollectionIncludes2 = _interopRequireDefault(_lodashCollectionIncludes);

var _lodashLangIsEqual = require('lodash/lang/isEqual');

var _lodashLangIsEqual2 = _interopRequireDefault(_lodashLangIsEqual);

var _lodashCollectionMap = require('lodash/collection/map');

var _lodashCollectionMap2 = _interopRequireDefault(_lodashCollectionMap);

var _lodashObjectMapValues = require('lodash/object/mapValues');

var _lodashObjectMapValues2 = _interopRequireDefault(_lodashObjectMapValues);

var _lodashMathMax = require('lodash/math/max');

var _lodashMathMax2 = _interopRequireDefault(_lodashMathMax);

var _lodashMathMin = require('lodash/math/min');

var _lodashMathMin2 = _interopRequireDefault(_lodashMathMin);

var _lodashCollectionPluck = require('lodash/collection/pluck');

var _lodashCollectionPluck2 = _interopRequireDefault(_lodashCollectionPluck);

var _lodashCollectionReduce = require('lodash/collection/reduce');

var _lodashCollectionReduce2 = _interopRequireDefault(_lodashCollectionReduce);

var _lodashCollectionReject = require('lodash/collection/reject');

var _lodashCollectionReject2 = _interopRequireDefault(_lodashCollectionReject);

var _lodashCollectionSize = require('lodash/collection/size');

var _lodashCollectionSize2 = _interopRequireDefault(_lodashCollectionSize);

var _lodashMathSum = require('lodash/math/sum');

var _lodashMathSum2 = _interopRequireDefault(_lodashMathSum);

var _lodashArrayUnion = require('lodash/array/union');

var _lodashArrayUnion2 = _interopRequireDefault(_lodashArrayUnion);

var _lodashArrayUniq = require('lodash/array/uniq');

var _lodashArrayUniq2 = _interopRequireDefault(_lodashArrayUniq);

var _gracefulFs = require('graceful-fs');

var _gracefulFs2 = _interopRequireDefault(_gracefulFs);

// - [ ] support "x from children" modifier
// - [ ] write tests

var RequiredKeyError = (function (_Error) {
    function RequiredKeyError(_ref) {
        var _ref$keys = _ref.keys;
        var keys = _ref$keys === undefined ? [] : _ref$keys;
        var _ref$msg = _ref.msg;
        var msg = _ref$msg === undefined ? '' : _ref$msg;
        var _ref$data = _ref.data;
        var data = _ref$data === undefined ? {} : _ref$data;

        _classCallCheck(this, RequiredKeyError);

        _get(Object.getPrototypeOf(RequiredKeyError.prototype), 'constructor', this).call(this);
        this.value = keys || msg;
        this.data = data;
    }

    _inherits(RequiredKeyError, _Error);

    _createClass(RequiredKeyError, [{
        key: 'toString',
        value: function toString() {
            return 'missing keys: ' + this.value + ' (from ' + self.data + ')';
        }
    }]);

    return RequiredKeyError;
})(Error);

var UnknownPropertyError = (function (_Error2) {
    function UnknownPropertyError(value) {
        _classCallCheck(this, UnknownPropertyError);

        _get(Object.getPrototypeOf(UnknownPropertyError.prototype), 'constructor', this).call(this);
        this.value = value;
    }

    _inherits(UnknownPropertyError, _Error2);

    _createClass(UnknownPropertyError, [{
        key: 'toString',
        value: function toString() {
            return 'unknown value: ' + this.value;
        }
    }]);

    return UnknownPropertyError;
})(Error);

var BadTypeError = (function (_Error3) {
    function BadTypeError(_ref2) {
        var _ref2$msg = _ref2.msg;
        var msg = _ref2$msg === undefined ? '' : _ref2$msg;
        var _ref2$data = _ref2.data;
        var data = _ref2$data === undefined ? {} : _ref2$data;

        _classCallCheck(this, BadTypeError);

        _get(Object.getPrototypeOf(BadTypeError.prototype), 'constructor', this).call(this, msg);
        this.value = msg;
        this.data = data;
    }

    _inherits(BadTypeError, _Error3);

    _createClass(BadTypeError, [{
        key: 'toString',
        value: function toString() {
            return this.value + ' ' + this.data;
        }
    }]);

    return BadTypeError;
})(Error);

// Helper Functions

function isRequirement(name) {
    return /^[A-Z]|[0-9][A-Z\- ]/.test(name);
}

function compareCourse(course, to) {
    // course might have more keys than the dict we're comparing it to
    // 'to' will have some combination of 'year', 'semester', 'department', 'number', and 'section'
    var _arr = ['year', 'semester', 'department', 'number', 'section'];
    for (var _i = 0; _i < _arr.length; _i++) {
        var key = _arr[_i];
        if (!(0, _lodashLangIsEqual2['default'])(course[key], to[key])) {
            return false;
        }
    }
    return true;
}

function checkForCourse(filter, courses) {
    return (0, _lodashCollectionAny2['default'])(courses, function (c) {
        return compareCourse(c, filter);
    });
}

function getOccurrences(course, courses) {
    return (0, _lodashCollectionFilter2['default'])(courses, function (c) {
        return compareCourse(c, _lodashCollectionFilter2['default']);
    });
}

function assertKeys(dict) {
    for (var _len = arguments.length, keys = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        keys[_key - 1] = arguments[_key];
    }

    var missingKeys = (0, _lodashCollectionReject2['default'])(keys, function (key) {
        return (0, _lodashCollectionIncludes2['default'])(Object.keys(dict), key);
    });
    if (missingKeys.length) {
        throw new RequiredKeyError({ keys: missingKeys, data: dict });
    }
}

function countCourses(courses) {
    // courses::pluck('crsid')::uniq()::len()
    return (0, _lodashCollectionSize2['default'])((0, _lodashArrayUniq2['default'])((0, _lodashCollectionPluck2['default'])(courses, 'crsid')));
}

function countDepartments(courses) {
    // courses::pluck('departments')::sum()
    return (0, _lodashMathSum2['default'])((0, _lodashCollectionPluck2['default'])(courses, 'departments'));
}

function countCredits(courses) {
    console.log('counting credits');
    return (0, _lodashMathSum2['default'])((0, _lodashCollectionPluck2['default'])(courses, 'credits'));
}

function pathToOverride(path) {
    return path.join('.').toLowerCase();
}

function hasOverride(path, overrides) {
    return pathToOverride(path) in overrides;
}

function getOverride(path, overrides) {
    return overrides[pathToOverride(path)];
}

function findOperatorType(operator) {
    if ('$eq' in operator) {
        return '$eq';
    } else if ('$ne' in operator) {
        return '$ne';
    } else if ('$lt' in operator) {
        return '$lt';
    } else if ('$lte' in operator) {
        return '$lte';
    } else if ('$gt' in operator) {
        return '$gt';
    } else if ('$gte' in operator) {
        return '$gte';
    } else {
        throw new RequiredKeyError({
            msg: 'no valid operators ($eq, $ne, $lt, $lte, $gt, $gte) could be found',
            data: operator });
    }
}

function compareCourseAgainstOperator(_x6, _x7, _x8) {
    var _again2 = true;

    _function2: while (_again2) {
        var course = _x6,
            key = _x7,
            operator = _x8;
        kind = simplifiedOperator = undefined;
        _again2 = false;

        // key: gereqs, operator: {$eq: "EIN"}
        // key: year, operator: {
        //     "$type": "operator",
        //     "$lte": {
        //       "$name": "max",
        //       "$prop": "year",
        //       "$type": "function",
        //       "$where": [{
        //         "$type": "qualification", "gereqs": {
        //           "$type": "operator", "$eq": "BTS-T"
        //         }
        //       }]
        //     }
        // } }

        var kind = findOperatorType(operator);

        if (typeof operator[kind] === 'object') {
            // we compute the value of the function-over-where-query style operators
            // earlier, in the filterByQualification function.
            assertKeys(operator[kind], '$computed-value');
            var simplifiedOperator = { kind: operator[kind]['$computed-value'] };
            _x6 = course;
            _x7 = key;
            _x8 = simplifiedOperator;
            _again2 = true;
            continue _function2;
        } else if (typeof operator[kind] === 'array') {
            throw new BadTypeError({
                msg: 'what would a comparison to a list even do? oh, wait; i\n            suppose it could compare against one of several values... well, im\n            not doing that right now. if you want it, edit the PEG and stick\n            appropriate stuff in here (probably simplest to just call this\n            function again with each possible value and return true if any are\n            true.)'
            });
        } else {
            // it's a static value; a number or string
            if (kind === '$eq' || kind === '$ne') return typeof course[key] === 'array' ? course[key] === operator[kind] : (0, _lodashCollectionIncludes2['default'])(course[key], operator[kind]);else if (kind === '$ne') return typeof course[key] === 'array' ? course[key] !== operator[kind] : !(0, _lodashCollectionIncludes2['default'])(course[key], operator[kind]);else if (kind === '$lt') return course[key] < operator[kind];else if (kind === '$lte') return course[key] <= operator[kind];else if (kind === '$gt') return course[key] > operator[kind];else if (kind === '$gte') return course[key] >= operator[kind];
        }
    }
}

function filterByQualification(list, qualification) {
    // { "$type":"qualification", $key: "gereqs", $value: {"$type": "operator", "$eq": "EIN"} }
    // { "$type":"qualification", $key: "year", value: {
    //     "$type": "operator",
    //     "$lte": {
    //       "$name": "max",
    //       "$prop": "year",
    //       "$type": "function",
    //       "$where": {
    //         "$type": "qualification", $key: "gereqs", $value: {
    //           "$type": "operator", "$eq": "BTS-T"
    //         }
    //       }
    //     }
    // } }

    var operator = qualification['$value'];
    var kind = findOperatorType(operator);

    if (typeof operator[kind] === 'object') {
        var value = operator[kind];
        if (value['$type'] === 'function') {
            var func = undefined;
            if (value['$name'] === 'max') func = _lodashMathMax2['default'];else if (value['$name'] === 'min') func = _lodashMathMin2['default'];else throw new RequiredKeyError({ msg: value['$name'] + ' is not a valid function to call.' });
            var _filtered = filterByWhereClause(list, value['$where']);
            var items = (0, _lodashCollectionPluck2['default'])(value['$prop'], _filtered);
            var computed = func(items);
            value['$computed-value'] = computed;
        }
    }

    console.log(qualification);
    var key = qualification['$key'];
    var filtered = (0, _lodashCollectionFilter2['default'])(list, function (course) {
        return compareCourseAgainstOperator(course, key, operator);
    });

    console.log(list.length, filtered.length);
    return filtered;
}

function filterByWhereClause(list, clause) {
    // {gereqs = EIN & year <= max(year) from {gereqs = BTS-T}}
    // {
    //    "$type": "boolean",
    //    "$and": [
    //      { "$type":"qualification", $key: "gereqs", $value: {"$type": "operator", "$eq": "EIN"} },
    //      { "$type":"qualification", $key: "year", $value: {
    //          "$type": "operator",
    //          "$lte": {
    //            "$name": "max",
    //            "$prop": "year",
    //            "$type": "function",
    //            "$where": {
    //              "$type": "qualification", $key: "gereqs", $value: {
    //                "$type": "operator", "$eq": "BTS-T"
    //              }
    //            }
    //          }
    //      } }
    //    ]
    //  }

    if (clause['$type'] === 'qualification') {
        return filterByQualification(list, clause);
    } else if (clause['$type'] === 'boolean') {
        if ('$and' in clause) {
            var _ret = (function () {
                var filtered = list;
                clause['$and'].forEach(function (q) {
                    filtered = filterByWhereClause(filtered, q);
                });
                return {
                    v: filtered
                };
            })();

            if (typeof _ret === 'object') return _ret.v;
        } else if ('$or' in clause) {
            var _ret2 = (function () {
                var filtrations = [];
                clause['$or'].forEach(function (q) {
                    filtrations = (0, _lodashArrayUnion2['default'])(filtrations, filterByWhereClause(list, q));
                });
                return {
                    v: (0, _lodashArrayUniq2['default'])(filtrations, 'crsid')
                };
            })();

            if (typeof _ret2 === 'object') return _ret2.v;
        } else {
            throw new RequiredKeyError({ msg: 'neither $or nor $and could be found', data: clause });
        }
    } else {
        console.log(clause);
        throw new BadTypeError({ msg: 'wth kind of type is this clause?', data: clause });
    }
}

// Compute Functions:
// There are two types of compute functions: those that need the surrounding
// context, and those that don't.

// Contained Computes:
// course, occurrence, where

function computeCourse(expr, courses) {
    var query = expr;
    delete query['$type'];
    return checkForCourse(query, courses);
}

function computeOccurrence(expr, courses) {
    assertKeys(expr, '$course', '$count');
    var clause = expr;
    delete clause['department'];
    delete clause['number'];
    delete clause['section'];
    var filtered = getOccurrences(clause, courses);
    return filtered.length >= expr['$count'];
}

function computeWhere(expr, courses) {
    assertKeys(expr, '$where', '$count');
    var filtered = filterByWhereClause(courses, expr['$where']);
    expr['_matches'] = filtered;
    return filtered.length >= expr['$count'];
}

// Contextual Computes:
// boolean, modifier, of, reference

function computeBoolean(expr, ctx, courses) {
    if ('$or' in expr) return (0, _lodashCollectionAny2['default'])((0, _lodashCollectionMap2['default'])(expr['$or'], function (req) {
        return computeChunk(req, ctx, courses);
    }));else if ('$and' in expr) return (0, _lodashCollectionAll2['default'])((0, _lodashCollectionMap2['default'])(expr['$and'], function (req) {
        return computeChunk(req, ctx, courses);
    }));else if ('$not' in expr) return !computeChunk(expr['$not'], ctx, courses);else {
        console.log();
        console.log(expr);
        throw new RequiredKeyError({ msg: 'none of $or, $and, or $not could be found' });
    }
}

function computeOf(expr, ctx, courses) {
    assertKeys(expr, '$of', '$count');

    var evaluated = (0, _lodashCollectionMap2['default'])(expr['$of'], function (req) {
        return computeChunk(req, ctx, courses);
    });
    var truthy = (0, _lodashCollectionFilter2['default'])(evaluated, _lodashUtilityIdentity2['default']);
    return truthy.length >= expr['$count'];
}

function computeReference(expr, ctx, courses) {
    assertKeys(expr, '$requirement');
    if (expr['$requirement'] in ctx) {
        var target = ctx[expr['$requirement']];
        return target['computed'];
    } else return false;
}

function computeModifier(expr, ctx, courses) {
    assertKeys(expr, '$what', '$count', '$from');
    var what = expr['$what'];

    if (!(0, _lodashCollectionIncludes2['default'])(['course', 'department', 'credit'], what)) throw new UnknownPropertyError(what);

    if (expr['$from'] === 'children') {
        console.error('not yet implemented');
        return false;
    } else if (expr['$from'] === 'where') {
        assertKeys(expr, '$where', '$count');
        var filtered = filterByWhereClause(courses, expr['$where']);
        var num = undefined;

        if (what === 'course') num = countCourses(filtered);else if (what === 'department') num = countDepartments(filtered);else if (what === 'credit') num = countCredits(filtered);

        return num >= expr['$count'];
    }
}

// And, of course, the function that dispatches the appropriate compute:

function computeChunk(expr, ctx, courses) {
    // print
    // print 'expression:', expr
    // print 'context:', ctx

    assertKeys(expr, '$type');
    var type = expr['$type'];

    var computed = false;
    if (type === 'boolean') computed = computeBoolean(expr, ctx, courses);else if (type === 'course') computed = computeCourse(expr, courses);else if (type === 'modifier') computed = computeModifier(expr, ctx, courses);else if (type === 'occurrence') computed = computeOccurrence(expr, courses);else if (type === 'of') computed = computeOf(expr, ctx, courses);else if (type === 'reference') computed = computeReference(expr, ctx, courses);else if (type === 'where') computed = computeWhere(expr, courses);

    expr['_result'] = computed;
    return computed;
}

// The overall computation === done by compute, which === in charge of computing
// sub-requirements and such.

function compute(requirement, path) {
    var courses = arguments[2] === undefined ? [] : arguments[2];
    var overrides = arguments[3] === undefined ? {} : arguments[3];

    // this_name = path[-1]
    // print ''
    // print requirement, this_name

    requirement = (0, _lodashObjectMapValues2['default'])(requirement, function (req, name) {
        return isRequirement(name) ? compute(req, path.concat([name]), courses, overrides) : req;
    });

    var computed = false;

    if ('result' in requirement) {
        computed = computeChunk(requirement['result'], requirement, courses);
    } else if ('message' in requirement) {
        computed = false
        // show a button to toggle overriding
        ;
    } else {
        // throw new RequiredKeyError(msg='one of message or result === required')
        print('one of message or result === required');
    }

    requirement['computed'] = computed;

    if (hasOverride(path, overrides)) {
        requirement['overridden'] = true;
        requirement['computed'] = getOverride(path, overrides);
    }

    return requirement;
}

function evaluate(student, area) {
    assertKeys(area, 'name', 'result', 'type', 'revision');
    var courses = student.courses;
    var overrides = student.overrides;
    var name = area.name;
    var type = area.type;

    return compute(area, [type, name], courses, overrides);
}

function loadFile(filename) {
    var data = _gracefulFs2['default'].readFileSync(filename, 'utf-8');
    return JSON.parse(data);
}

function main() {
    if (process.argv.length < 3) {
        console.log('usage: evaluate areaFile [student]');
        return;
    }

    var areaFile = undefined,
        studentFile = undefined;
    if (process.argv.length >= 3) {
        areaFile = process.argv[2];
        studentFile = process.argv[3] || './student.json';
    }

    var _loadFile = loadFile(studentFile);

    var courses = _loadFile.courses;
    var overrides = _loadFile.overrides;

    var result = evaluate({ courses: courses, overrides: overrides }, loadFile(areaFile));
    // evaluate('', '')

    console.log(JSON.stringify(result, null, 2));
    console.log('outcome:', result['computed']);
}

main();

